{
  "version": 3,
  "sources": ["../../node_modules/thirdweb/src/wallets/constants.ts", "../../node_modules/thirdweb/src/wallets/coinbase/coinbase-web.ts"],
  "sourcesContent": ["// Constants for most common wallets\nexport const COINBASE = \"com.coinbase.wallet\";\nexport const METAMASK = \"io.metamask\";\nexport const RAINBOW = \"me.rainbow\";\nexport const ZERION = \"io.zerion.wallet\";\n", "import type { ProviderInterface } from \"@coinbase/wallet-sdk\";\nimport type { Preference } from \"@coinbase/wallet-sdk/dist/core/provider/interface.js\";\nimport type { Address } from \"abitype\";\nimport * as ox__Hex from \"ox/Hex\";\nimport * as ox__TypedData from \"ox/TypedData\";\nimport { trackTransaction } from \"../../analytics/track/transaction.js\";\nimport type { Chain } from \"../../chains/types.js\";\nimport { getCachedChain, getChainMetadata } from \"../../chains/utils.js\";\nimport type { ThirdwebClient } from \"../../client/client.js\";\nimport { getAddress } from \"../../utils/address.js\";\nimport {\n  type Hex,\n  numberToHex,\n  stringToHex,\n  uint8ArrayToHex,\n} from \"../../utils/encoding/hex.js\";\nimport { parseTypedData } from \"../../utils/signatures/helpers/parse-typed-data.js\";\nimport { COINBASE } from \"../constants.js\";\nimport type {\n  Account,\n  SendTransactionOption,\n  Wallet,\n} from \"../interfaces/wallet.js\";\nimport type { AppMetadata, DisconnectFn, SwitchChainFn } from \"../types.js\";\nimport { getValidPublicRPCUrl } from \"../utils/chains.js\";\nimport { getDefaultAppMetadata } from \"../utils/defaultDappMetadata.js\";\nimport { normalizeChainId } from \"../utils/normalizeChainId.js\";\nimport type { WalletEmitter } from \"../wallet-emitter.js\";\nimport type {\n  CreateWalletArgs,\n  WalletConnectionOption,\n} from \"../wallet-types.js\";\nimport { showCoinbasePopup } from \"./utils.js\";\n\nexport type CoinbaseWalletCreationOptions =\n  | {\n      /**\n       * Metadata of the dApp that will be passed to connected wallet.\n       *\n       * Some wallets may display this information to the user.\n       *\n       * Setting this property is highly recommended. If this is not set, Below default metadata will be used:\n       *\n       * ```ts\n       * {\n       *   name: \"thirdweb powered dApp\",\n       *   url: \"https://thirdweb.com\",\n       *   description: \"thirdweb powered dApp\",\n       *   logoUrl: \"https://thirdweb.com/favicon.ico\",\n       * };\n       * ```\n       */\n      appMetadata?: AppMetadata;\n\n      /**\n       * Wallet configuration, choices are 'all' | 'smartWalletOnly' | 'eoaOnly'\n       * @default 'all'\n       * @example\n       * ```ts\n       * {\n       *  walletConfig: {\n       *   options: 'all',\n       *  }\n       * }\n       * ```\n       */\n      walletConfig?: Preference;\n\n      /**\n       * Chains that the wallet can switch chains to, will default to the first chain in this array on first connection.\n       * @default Ethereum mainnet\n       * @example\n       * ```ts\n       * {\n       *   chains: [base, optimisim]\n       * }\n       */\n      chains?: Chain[];\n\n      mobileConfig?: {\n        /**\n         * The univeral callback URL to redirect the user to after they have completed the wallet connection with the cb wallet app.\n         * This needs to be setup as a Universal link for iOS https://docs.cdp.coinbase.com/wallet-sdk/docs/ios-setup/\n         * and App link on Android https://docs.cdp.coinbase.com/wallet-sdk/docs/android-setup/\n         */\n        callbackURL?: string;\n      };\n    }\n  | undefined;\n\n/**\n * Options for connecting to the CoinbaseSDK Wallet\n */\nexport type CoinbaseSDKWalletConnectionOptions = {\n  /**\n   * The Thirdweb client object\n   */\n  client: ThirdwebClient;\n\n  /**\n   * If you want the wallet to be connected to a specific blockchain, you can pass a `Chain` object to the `connect` method.\n   * This will trigger a chain switch if the wallet provider is not already connected to the specified chain.\n   *\n   * You can create a `Chain` object using the [`defineChain`](https://portal.thirdweb.com/references/typescript/v5/defineChain) function.\n   * At minimum, you need to pass the `id` of the blockchain.\n   *\n   * ```ts\n   * import { defineChain } from \"thirdweb\";\n   * const myChain = defineChain(myChainId);\n   *\n   * const address = await wallet.connect({ chain: myChain })\n   */\n  chain?: Chain;\n};\n\n// Need to keep the provider around because it keeps a single popup window connection behind the scenes\n// this should be ok since all the creation options are provided at build time\nlet _provider: ProviderInterface | undefined;\n\n/**\n * @internal\n */\nexport async function getCoinbaseWebProvider(\n  options?: CreateWalletArgs<typeof COINBASE>[1],\n): Promise<ProviderInterface> {\n  if (!_provider) {\n    let CoinbaseWalletSDK: unknown = (await import(\"@coinbase/wallet-sdk\"))\n      .default;\n    // Workaround for Vite dev import errors\n    // https://github.com/vitejs/vite/issues/7112\n    if (\n      typeof CoinbaseWalletSDK !== \"function\" &&\n      typeof (CoinbaseWalletSDK as { default: unknown }).default === \"function\"\n    ) {\n      CoinbaseWalletSDK = (\n        CoinbaseWalletSDK as unknown as { default: typeof CoinbaseWalletSDK }\n      ).default;\n    }\n\n    // @ts-expect-error This import error is not visible to TypeScript\n    const client = new CoinbaseWalletSDK({\n      appChainIds: options?.chains\n        ? options.chains.map((c) => c.id)\n        : undefined,\n      appLogoUrl:\n        options?.appMetadata?.logoUrl || getDefaultAppMetadata().logoUrl,\n      appName: options?.appMetadata?.name || getDefaultAppMetadata().name,\n    });\n\n    const provider = client.makeWeb3Provider(options?.walletConfig);\n    _provider = provider;\n    return provider;\n  }\n  return _provider;\n}\n\n/**\n * Checks if the provided wallet is a Coinbase SDK wallet.\n *\n * @param wallet - The wallet to check.\n * @returns True if the wallet is a Coinbase SDK wallet, false otherwise.\n */\nexport function isCoinbaseSDKWallet(\n  wallet: Wallet,\n): wallet is Wallet<typeof COINBASE> {\n  return wallet.id === COINBASE;\n}\n\nfunction createAccount({\n  provider,\n  address,\n  client,\n}: {\n  provider: ProviderInterface;\n  address: string;\n  client: ThirdwebClient;\n}) {\n  const account: Account = {\n    address: getAddress(address),\n    onTransactionRequested: async () => {\n      // make sure to show the coinbase popup BEFORE doing any transaction preprocessing\n      // otherwise the popup might get blocked in safari\n      await showCoinbasePopup(provider);\n    },\n    async sendTransaction(tx: SendTransactionOption) {\n      const transactionHash = (await provider.request({\n        method: \"eth_sendTransaction\",\n        params: [\n          {\n            accessList: tx.accessList,\n            data: tx.data,\n            from: getAddress(address),\n            gas: tx.gas ? numberToHex(tx.gas) : undefined,\n            to: tx.to as Address,\n            value: tx.value ? numberToHex(tx.value) : undefined,\n          },\n        ],\n      })) as Hex;\n\n      trackTransaction({\n        chainId: tx.chainId,\n        client: client,\n        contractAddress: tx.to ?? undefined,\n        gasPrice: tx.gasPrice,\n        transactionHash,\n        walletAddress: getAddress(address),\n        walletType: COINBASE,\n      });\n\n      return {\n        transactionHash,\n      };\n    },\n    async signMessage({ message }) {\n      if (!account.address) {\n        throw new Error(\"Provider not setup\");\n      }\n\n      const messageToSign = (() => {\n        if (typeof message === \"string\") {\n          return stringToHex(message);\n        }\n        if (message.raw instanceof Uint8Array) {\n          return uint8ArrayToHex(message.raw);\n        }\n        return message.raw;\n      })();\n\n      const res = await provider.request({\n        method: \"personal_sign\",\n        params: [messageToSign, account.address],\n      });\n      if (!ox__Hex.validate(res)) {\n        throw new Error(\"Invalid signature returned\");\n      }\n      return res;\n    },\n    async signTypedData(typedData) {\n      if (!account.address) {\n        throw new Error(\"Provider not setup\");\n      }\n\n      const { domain, message, primaryType } = parseTypedData(\n        typedData,\n      ) as ox__TypedData.Definition;\n\n      const types = {\n        EIP712Domain: ox__TypedData.extractEip712DomainTypes(domain),\n        ...typedData.types,\n      };\n\n      // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n      // as we can't statically check this with TypeScript.\n      ox__TypedData.validate({ domain, message, primaryType, types });\n\n      const stringifiedData = ox__TypedData.serialize({\n        domain: domain ?? {},\n        message,\n        primaryType,\n        types,\n      });\n\n      const res = await provider.request({\n        method: \"eth_signTypedData_v4\",\n        params: [account.address, stringifiedData],\n      });\n      if (!ox__Hex.validate(res)) {\n        throw new Error(\"Invalid signed payload returned\");\n      }\n      return res;\n    },\n  };\n\n  return account;\n}\n\nfunction onConnect(\n  address: string,\n  chain: Chain,\n  provider: ProviderInterface,\n  emitter: WalletEmitter<typeof COINBASE>,\n  client: ThirdwebClient,\n): [Account, Chain, DisconnectFn, SwitchChainFn] {\n  const account = createAccount({ address, client, provider });\n\n  async function disconnect() {\n    provider.removeListener(\"accountsChanged\", onAccountsChanged);\n    provider.removeListener(\"chainChanged\", onChainChanged);\n    provider.removeListener(\"disconnect\", onDisconnect);\n    await provider.disconnect();\n  }\n\n  async function onDisconnect() {\n    disconnect();\n    emitter.emit(\"disconnect\", undefined);\n  }\n\n  function onAccountsChanged(accounts: string[]) {\n    if (accounts[0]) {\n      const newAccount = createAccount({\n        address: getAddress(accounts[0]),\n        client,\n        provider,\n      });\n      emitter.emit(\"accountChanged\", newAccount);\n      emitter.emit(\"accountsChanged\", accounts);\n    } else {\n      onDisconnect();\n    }\n  }\n\n  function onChainChanged(newChainId: string) {\n    const newChain = getCachedChain(normalizeChainId(newChainId));\n    emitter.emit(\"chainChanged\", newChain);\n  }\n\n  // subscribe to events\n  provider.on(\"accountsChanged\", onAccountsChanged);\n  provider.on(\"chainChanged\", onChainChanged);\n  provider.on(\"disconnect\", onDisconnect);\n\n  return [\n    account,\n    chain,\n    onDisconnect,\n    (newChain) => switchChainCoinbaseWalletSDK(provider, newChain),\n  ];\n}\n\n/**\n * @internal\n */\nexport async function connectCoinbaseWalletSDK(\n  options: WalletConnectionOption<typeof COINBASE>,\n  emitter: WalletEmitter<typeof COINBASE>,\n  provider: ProviderInterface,\n): Promise<ReturnType<typeof onConnect>> {\n  const accounts = (await provider.request({\n    method: \"eth_requestAccounts\",\n  })) as string[];\n\n  if (!accounts[0]) {\n    throw new Error(\"No accounts found\");\n  }\n\n  const address = getAddress(accounts[0]);\n\n  const connectedChainId = (await provider.request({\n    method: \"eth_chainId\",\n  })) as string | number;\n\n  const chainId = normalizeChainId(connectedChainId);\n  let chain =\n    options.chain && options.chain.id === chainId\n      ? options.chain\n      : getCachedChain(chainId);\n  // Switch to chain if provided\n  if (chainId && options?.chain && chainId !== options?.chain.id) {\n    await switchChainCoinbaseWalletSDK(provider, options.chain);\n    chain = options.chain;\n  }\n\n  return onConnect(address, chain, provider, emitter, options.client);\n}\n\n/**\n * @internal\n */\nexport async function autoConnectCoinbaseWalletSDK(\n  options: WalletConnectionOption<typeof COINBASE>,\n  emitter: WalletEmitter<typeof COINBASE>,\n  provider: ProviderInterface,\n): Promise<ReturnType<typeof onConnect>> {\n  // connected accounts\n  const addresses = (await provider.request({\n    method: \"eth_accounts\",\n  })) as string[];\n\n  const address = addresses[0];\n\n  if (!address) {\n    throw new Error(\"No accounts found\");\n  }\n\n  const connectedChainId = (await provider.request({\n    method: \"eth_chainId\",\n  })) as string | number;\n  const chainId = normalizeChainId(connectedChainId);\n  const chain =\n    options.chain && options.chain.id === chainId\n      ? options.chain\n      : getCachedChain(chainId);\n\n  return onConnect(address, chain, provider, emitter, options.client);\n}\n\nasync function switchChainCoinbaseWalletSDK(\n  provider: ProviderInterface,\n  chain: Chain,\n) {\n  const chainIdHex = numberToHex(chain.id);\n\n  try {\n    await provider.request({\n      method: \"wallet_switchEthereumChain\",\n      params: [{ chainId: chainIdHex }],\n    });\n  } catch (error) {\n    const apiChain = await getChainMetadata(chain);\n\n    // Indicates chain is not added to provider\n    // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\n    if ((error as any)?.code === 4902) {\n      // try to add the chain\n      await provider.request({\n        method: \"wallet_addEthereumChain\",\n        params: [\n          {\n            blockExplorerUrls: apiChain.explorers?.map((x) => x.url) || [],\n            chainId: chainIdHex,\n            chainName: apiChain.name,\n            nativeCurrency: apiChain.nativeCurrency, // no client id on purpose here\n            rpcUrls: getValidPublicRPCUrl(apiChain),\n          },\n        ],\n      });\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": ["validate"]
}
